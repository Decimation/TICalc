; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\LIBRARY.C"
	.assume ADL=1
	SEGMENT TEXT
_rounders:
	DF	0.5
	DF	0.05
	DF	0.005
	DF	0.0005
	DF	0.00005
	DF	5.0E-6
	DF	5.0E-7
	DF	5.0E-8
	DF	5.0E-9
	DF	5.0E-10
	DF	5.0E-11
	SEGMENT BSS
_g_response:
	DS	20
_g_inputBuffer:
	DS	10
;    1	/* Keep these headers */
;    2	
;    3	#include <math.h>
;    4	#include "C:\CEdev\include\stddef.h"
;    5	#include "C:\CEdev\include\stdbool.h"
;    6	#include "C:\CEdev\include\tice.h"
;    7	#include "C:\CEdev\include\fileioc.h"
;    8	#include "C:\CEdev\include\stdint.h"
;    9	#include "Library.h"
;   10	#include "IO.h"
;   11	
;   12	
;   13	
;   14	/**
;   15	 * THESE MUST BE GLOBAL OR ELSE EXITING
;   16	 * THE ENTRY POINT WILL CAUSE AN NMI RESET
;   17	 */
;   18	char    g_response[RESP_SIZE];
;   19	char    g_inputBuffer[INPUT_SIZE];
	SEGMENT CODE
;   20	//int24_t g_value;
;   21	
;   22	void prepend(char* s, const char* t)
;   23	{
_prepend:
	LD	HL,-6
	CALL	__frameset
;   24		size_t len = strlen(t);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-6),HL
;   25		size_t i;
;   26	
;   27		memmove(s + len, s, strlen(s) + 1);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	INC	HL
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	HL,(IX+6)
	ADD	HL,BC
	PUSH	HL
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;   28	
;   29		for (i = 0; i < len; ++i)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_2
L_0:
;   30		{
;   31			s[i] = t[i];
	LD	BC,(IX+-3)
	LD	HL,(IX+9)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+6)
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;   32		}
L_2:
	LD	BC,(IX+-6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_0
;   33	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _prepend ***************************
;Name                         Addr/Register   Size   Type
;_memmove                            IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;len                                   IX-6      3   variable
;i                                     IX-3      3   variable
;t                                     IX+9      3   parameter
;s                                     IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;   34	
;   35	int indexOf(char* values, char find)
;   36	{
_indexOf:
	LD	HL,-6
	CALL	__frameset
;   37		int index;
;   38		const char* ptr = strchr(values, find);
	LD	A,(IX+9)
	SEXT	HL
	LD	L,(IX+9)
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strchr
	POP	BC
	POP	BC
	LD	(IX+-6),HL
;   39	
;   40		index = ptr - values;
	LD	BC,(IX+6)
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-3),HL
;   41		return index;
;   42	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _indexOf ***************************
;Name                         Addr/Register   Size   Type
;_strchr                             IMPORT  -----   function
;ptr                                   IX-6      3   variable
;index                                 IX-3      3   variable
;find                                  IX+9      1   parameter
;values                                IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;   43	
;   44	char intToChar(int c)
;   45	{
_intToChar:
	CALL	__frameset0
;   46		return c + '0';
	LD	A,(IX+6)
	ADD	A,48
;   47	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _intToChar ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   48	
;   49	int GetMantissa(float f)
;   50	{
_GetMantissa:
	LD	HL,-43
	CALL	__frameset
;   51		char fstr[20];
;   52		char mstr[20];
;   53		int  i;
;   54		sprintf(fstr, "%f", f);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,L__4
	PUSH	BC
	PEA	IX+-23
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   55	
;   56		i = 0;
	LD	BC,0
	LD	(IX+-3),BC
;   57	
;   58		for (; fstr[indexOf(fstr, '.') + 1 + i] != '\0'; i++)
	JR	L_9
L_7:
;   59		{
;   60			mstr[i] = fstr[indexOf(fstr, '.') + 1 + i];
	LD	BC,46
	PUSH	BC
	PEA	IX+-23
	CALL	_indexOf
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	HL
	ADD	HL,BC
	LD	BC,HL
	LEA	HL,IX+-23
	ADD	HL,BC
	LD	A,(HL)
	LEA	HL,IX+-43
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;   61		}
L_9:
	LD	BC,46
	PUSH	BC
	PEA	IX+-23
	CALL	_indexOf
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	HL
	ADD	HL,BC
	LD	BC,HL
	LEA	HL,IX+-23
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_7
;   62		return atoi(mstr);
	PEA	IX+-43
	CALL	_atoi
	POP	BC
;   63	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetMantissa ***************************
;Name                         Addr/Register   Size   Type
;_atoi                               IMPORT  -----   function
;_indexOf                            IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;mstr                                 IX-43     20   variable
;fstr                                 IX-23     20   variable
;i                                     IX-3      3   variable
;f                                     IX+6      4   parameter


; Stack Frame Size: 55 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__4:
	DB	"%f"
	DB	0
	SEGMENT CODE
;   64	
;   65	int str_cut(char* str, int begin, int len)
;   66	{
_str_cut:
	LD	HL,-6
	CALL	__frameset
;   67		int l = strlen(str);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-3),HL
;   68	
;   69		if (len < 0) len         = l - begin;
	LD	HL,(IX+12)
	CALL	__icmpzero
	JP	P,L_14
	LD	BC,(IX+9)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	LD	(IX+12),HL
L_14:
;   70		if (begin + len > l) len = l - begin;
	LD	BC,(IX+12)
	LD	HL,(IX+9)
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_15
	LD	BC,(IX+9)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	LD	(IX+12),HL
L_15:
;   71		memmove(str + begin, str + begin + len, l - len + 1);
	LD	BC,(IX+9)
	LD	HL,(IX+6)
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	INC	HL
	PUSH	HL
	LD	BC,(IX+12)
	LD	HL,(IX+-6)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;   72	
;   73		return len;
	LD	HL,(IX+12)
;   74	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _str_cut ***************************
;Name                         Addr/Register   Size   Type
;_memmove                            IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;l                                     IX-3      3   variable
;len                                  IX+12      3   parameter
;begin                                 IX+9      3   parameter
;str                                   IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


;   75	
;   76	float StringToFloat(char* in)
;   77	{
_StringToFloat:
	CALL	__frameset0
;   78		in[indexOf(in, ':')] = '.';
	LD	BC,58
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_indexOf
	POP	BC
	POP	BC
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(HL),46
;   79		return atof(in);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_atof
	POP	BC
;   80	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _StringToFloat ***************************
;Name                         Addr/Register   Size   Type
;_atof                               IMPORT  -----   function
;_indexOf                            IMPORT  -----   function
;in                                    IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   81	
;   82	char* FloatToString(double f, char* buf, int precision)
;   83	{
_FloatToString:
	LD	HL,-29
	CALL	__frameset
;   84		char* ptr = buf;
	LD	BC,(IX+12)
	LD	(IX+-3),BC
;   85		char* p   = ptr;
;   86		char* p1;
;   87		char c;
;   88		long intPart;
;   89	
;   90		// check precision bounds
;   91		if (precision > MAX_PRECISION)
	LD	BC,(IX+15)
	LD	HL,10
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_21
;   92			precision = MAX_PRECISION;
	LD	BC,10
	LD	(IX+15),BC
L_21:
;   93	
;   94		// sign stuff
;   95		if (f < 0)
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_35
;   96		{
;   97			f = -f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
;   98			*ptr++ = '-';
	LD	HL,(IX+12)
	LD	(HL),45
	LD	BC,(IX+12)
	INC	BC
	LD	(IX+-3),BC
;   99		}
L_35:
;  100	
;  101		if (precision < 0)  // negative precision == automatic precision guess
	LD	HL,(IX+15)
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_37
;  102		{
;  103			if (f < 1.0) precision = 6;
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JP	P,L_33
	LD	BC,6
	LD	(IX+15),BC
;  104			else if (f < 10.0) precision = 5;
	JR	L_37
L_33:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JP	P,L_31
	LD	BC,5
	LD	(IX+15),BC
;  105			else if (f < 100.0) precision = 4;
	JR	L_37
L_31:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,13107200
	LD	A,66
	CALL	__fcmp
	JP	P,L_29
	LD	BC,4
	LD	(IX+15),BC
;  106			else if (f < 1000.0) precision = 3;
	JR	L_37
L_29:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,7995392
	LD	A,68
	CALL	__fcmp
	JP	P,L_27
	LD	BC,3
	LD	(IX+15),BC
;  107			else if (f < 10000.0) precision = 2;
	JR	L_37
L_27:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,1851392
	LD	A,70
	CALL	__fcmp
	JP	P,L_25
	LD	BC,2
	LD	(IX+15),BC
;  108			else if (f < 100000.0) precision = 1;
	JR	L_37
L_25:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,12800000
	LD	A,71
	CALL	__fcmp
	JP	P,L_23
	LD	BC,1
	LD	(IX+15),BC
;  109			else precision = 0;
	JR	L_37
L_23:
	LD	BC,0
	LD	(IX+15),BC
;  110		}
L_37:
;  111	
;  112		// round value according the precision
;  113		if (precision)
	LD	HL,(IX+15)
	CALL	__icmpzero
	JR	Z,L_38
;  114			f += rounders[precision];
	LD	HL,(IX+15)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_rounders
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+6)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	E,(IX+9)
	CALL	__fadd
	LD	(IX+6),BC
	LD	(IX+9),A
L_38:
;  115	
;  116		// integer part...
;  117		intPart = f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	(IX+-10),BC
	LD	(IX+-7),A
;  118		f -= intPart;
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  119	
;  120		if (!intPart)
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	CALL	__lcmpzero
	JR	NZ,L_49
;  121			*ptr++ = '0';
	LD	BC,(IX+-3)
	LD	(IX+-17),BC
	LD	HL,BC
	LD	(HL),48
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  122		else
	JR	L_56
L_49:
;  123		{
;  124			// save start pointer
;  125			p = ptr;
	LD	BC,(IX+-3)
	LD	(IX+-6),BC
;  126	
;  127			// convert (reverse order)
;  128			while (intPart)
	JR	L_41
L_42:
;  129			{
;  130				*p++ = '0' + intPart % 10;
	LD	BC,(IX+-6)
	LD	(IX+-20),BC
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	LD	BC,10
	XOR	A,A
	CALL	__lrems
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-20)
	LD	(HL),A
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  131				intPart /= 10;
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	XOR	A,A
	LD	BC,10
	CALL	__ldivs
	LD	(IX+-10),HL
	LD	(IX+-7),E
;  132			}
L_41:
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	CALL	__lcmpzero
	JR	NZ,L_42
;  133	
;  134			// save end pos
;  135			p1 = p;
	LD	BC,(IX+-6)
	LD	(IX+-14),BC
;  136	
;  137			// reverse result
;  138			while (p > ptr)
	JR	L_45
L_46:
;  139			{
;  140				c = *--p;
	LD	IY,(IX+-6)
	LEA	IY,IY+-1
	LD	(IX+-6),IY
	LD	HL,(IX+-6)
	LD	A,(HL)
	LD	(IX+-11),A
;  141				*p     = *ptr;
	LD	HL,(IX+-3)
	LD	A,(HL)
	LD	HL,(IX+-6)
	LD	(HL),A
;  142				*ptr++ = c;
	LD	BC,(IX+-3)
	LD	(IX+-23),BC
	LD	HL,BC
	LD	A,(IX+-11)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  143			}
L_45:
	LD	BC,(IX+-6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_46
;  144	
;  145			// restore end pos
;  146			ptr = p1;
	LD	BC,(IX+-14)
	LD	(IX+-3),BC
;  147		}
L_56:
;  148	
;  149		// decimal part
;  150		if (precision)
	LD	HL,(IX+15)
	CALL	__icmpzero
	JR	Z,L_57
;  151		{
;  152			// place decimal point
;  153			*ptr++ = '.';
	LD	BC,(IX+-3)
	LD	(IX+-26),BC
	LD	HL,BC
	LD	(HL),46
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  154	
;  155			// convert
;  156			while (precision--)
	JR	L_53
L_54:
;  157			{
;  158				f *= 10.0;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	(IX+6),BC
	LD	(IX+9),A
;  159				c = f;
;  160				*ptr++ = '0' + c;
	LD	DE,(IX+-3)
	LD	(IX+-29),DE
	LD	A,(IX+9)
	CALL	__ftol
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-29)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  161				f -= c;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	A,C
	SEXT	HL
	LD	L,C
	LD	A,H
	LD	BC,HL
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  162			}
L_53:
	LD	BC,(IX+15)
	DEC	BC
	LD	HL,(IX+15)
	CALL	__icmpzero
	LD	(IX+15),BC
	JR	NZ,L_54
;  163		}
L_57:
;  164	
;  165		// terminating zero
;  166		*ptr = 0;
	LD	HL,(IX+-3)
	LD	(HL),0
;  167	
;  168		return buf;
	LD	HL,(IX+12)
;  169	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _FloatToString ***************************
;Name                         Addr/Register   Size   Type
;_rounders                           STATIC     44   variable
;p1                                   IX-14      3   variable
;c                                    IX-11      1   variable
;intPart                              IX-10      4   variable
;p                                     IX-6      3   variable
;ptr                                   IX-3      3   variable
;precision                            IX+15      3   parameter
;buf                                  IX+12      3   parameter
;f                                     IX+6      4   parameter


; Stack Frame Size: 47 (bytes)
;       Spill Code: 0 (instruction)


	XREF _strlen:ROM
	XREF _strchr:ROM
	XREF _memmove:ROM
	XREF _sprintf:ROM
	XREF _atoi:ROM
	XREF _atof:ROM
	XREF __ldivs:ROM
	XREF __lrems:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XDEF _FloatToString
	XDEF _StringToFloat
	XDEF _str_cut
	XDEF _GetMantissa
	XDEF _intToChar
	XDEF _indexOf
	XDEF _prepend
	XDEF _g_inputBuffer
	XDEF _g_response
	END
