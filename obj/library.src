; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\LIBRARY.C"
	.assume ADL=1
	SEGMENT BSS
_g_response:
	DS	20
_g_inputBuffer:
	DS	10
;    1	/* Keep these headers */
;    2	
;    3	#include <math.h>
;    4	#include "C:\CEdev\include\stddef.h"
;    5	#include "C:\CEdev\include\stdbool.h"
;    6	#include "C:\CEdev\include\fileioc.h"
;    7	#include "Library.h"
;    8	#include "IO.h"
;    9	
;   10	
;   11	/**
;   12	 * THESE MUST BE GLOBAL OR ELSE EXITING
;   13	 * THE ENTRY POINT WILL CAUSE AN NMI RESET
;   14	 */
;   15	char g_response[RESP_SIZE];
;   16	char g_inputBuffer[INPUT_SIZE];
	SEGMENT CODE
;   17	//int24_t g_value;
;   18	
;   19	void EchoInput(int i) {
_EchoInput:
	CALL	__frameset0
;   20		sprintf(g_response, "(%d)", i);
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,L__0
	PUSH	BC
	LD	BC,_g_response
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;   21		print(g_response, 15, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,_g_response
	PUSH	BC
	CALL	_print
	POP	BC
	POP	BC
	POP	BC
;   22	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _EchoInput ***************************
;Name                         Addr/Register   Size   Type
;_print                              IMPORT  -----   function
;_g_response                         STATIC     20   variable
;_sprintf                            IMPORT  -----   function
;i                                     IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__0:
	DB	"(%d)"
	DB	0
	SEGMENT CODE
;   23	
;   24	void Prepend(char* s, const char* t)
;   25	{
_Prepend:
	LD	HL,-6
	CALL	__frameset
;   26		size_t len = strlen(t);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-6),HL
;   27		size_t i;
;   28	
;   29		memmove(s + len, s, strlen(s) + 1);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	INC	HL
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,(IX+-6)
	LD	HL,(IX+6)
	ADD	HL,BC
	PUSH	HL
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;   30	
;   31		for (i = 0; i < len; ++i)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
;   32		{
;   33			s[i] = t[i];
	LD	BC,(IX+-3)
	LD	HL,(IX+9)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+6)
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;   34		}
L_3:
	LD	BC,(IX+-6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_1
;   35	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _Prepend ***************************
;Name                         Addr/Register   Size   Type
;_memmove                            IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;len                                   IX-6      3   variable
;i                                     IX-3      3   variable
;t                                     IX+9      3   parameter
;s                                     IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;   36	
;   37	int IndexOf(char* values, char find)
;   38	{
_IndexOf:
	LD	HL,-6
	CALL	__frameset
;   39		int index;
;   40		const char* ptr = strchr(values, find);
	LD	A,(IX+9)
	SEXT	HL
	LD	L,(IX+9)
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strchr
	POP	BC
	POP	BC
	LD	(IX+-6),HL
;   41		if (ptr)
	CALL	__icmpzero
	JR	Z,L_6
;   42		{
;   43			index = (int) (ptr - values);
	LD	BC,(IX+6)
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-3),HL
;   44		}
;   45		else index = -1;
	JR	L_7
L_6:
	LD	BC,16777215
	LD	(IX+-3),BC
L_7:
;   46		return index;
	LD	HL,(IX+-3)
;   47	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _IndexOf ***************************
;Name                         Addr/Register   Size   Type
;_strchr                             IMPORT  -----   function
;ptr                                   IX-6      3   variable
;index                                 IX-3      3   variable
;find                                  IX+9      1   parameter
;values                                IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;   48	
;   49	char IntToChar(int c)
;   50	{
_IntToChar:
	CALL	__frameset0
;   51		return c + '0';
	LD	A,(IX+6)
	ADD	A,48
;   52	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _IntToChar ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   53	
;   54	int GetMantissa(float f)
;   55	{
_GetMantissa:
	LD	HL,-43
	CALL	__frameset
;   56		char fstr[20];
;   57		char mstr[20];
;   58		int  i;
;   59		sprintf(fstr, "%f", f);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,L__7
	PUSH	BC
	PEA	IX+-23
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   60	
;   61		i = 0;
	LD	BC,0
	LD	(IX+-3),BC
;   62	
;   63		for (; fstr[IndexOf(fstr, '.') + 1 + i] != '\0'; i++)
	JR	L_13
L_11:
;   64		{
;   65			mstr[i] = fstr[IndexOf(fstr, '.') + 1 + i];
	LD	BC,46
	PUSH	BC
	PEA	IX+-23
	CALL	_IndexOf
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	HL
	ADD	HL,BC
	LD	BC,HL
	LEA	HL,IX+-23
	ADD	HL,BC
	LD	A,(HL)
	LEA	HL,IX+-43
	LD	BC,(IX+-3)
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;   66		}
L_13:
	LD	BC,46
	PUSH	BC
	PEA	IX+-23
	CALL	_IndexOf
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	HL
	ADD	HL,BC
	LD	BC,HL
	LEA	HL,IX+-23
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_11
;   67		return atoi(mstr);
	PEA	IX+-43
	CALL	_atoi
	POP	BC
;   68	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetMantissa ***************************
;Name                         Addr/Register   Size   Type
;_atoi                               IMPORT  -----   function
;_IndexOf                            IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;mstr                                 IX-43     20   variable
;fstr                                 IX-23     20   variable
;i                                     IX-3      3   variable
;f                                     IX+6      4   parameter


; Stack Frame Size: 55 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__7:
	DB	"%f"
	DB	0
	SEGMENT CODE
;   69	
;   70	int StrCut(char* str, int begin, int len)
;   71	{
_StrCut:
	LD	HL,-6
	CALL	__frameset
;   72		int l = strlen(str);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-3),HL
;   73	
;   74		if (len < 0) len         = l - begin;
	LD	HL,(IX+12)
	CALL	__icmpzero
	JP	P,L_18
	LD	BC,(IX+9)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	LD	(IX+12),HL
L_18:
;   75		if (begin + len > l) len = l - begin;
	LD	BC,(IX+12)
	LD	HL,(IX+9)
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_19
	LD	BC,(IX+9)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	LD	(IX+12),HL
L_19:
;   76		memmove(str + begin, str + begin + len, l - len + 1);
	LD	BC,(IX+9)
	LD	HL,(IX+6)
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	INC	HL
	PUSH	HL
	LD	BC,(IX+12)
	LD	HL,(IX+-6)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;   77	
;   78		return len;
	LD	HL,(IX+12)
;   79	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _StrCut ***************************
;Name                         Addr/Register   Size   Type
;_memmove                            IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;l                                     IX-3      3   variable
;len                                  IX+12      3   parameter
;begin                                 IX+9      3   parameter
;str                                   IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


;   80	
;   81	int IsEven(double d)
;   82	{
_IsEven:
	LD	HL,-4
	CALL	__frameset
;   83		double int_part;
;   84		modf(d / 2.0, &int_part);
	PEA	IX+-4
	LD	BC,(IX+6)
	LD	A,(IX+9)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_modf
	POP	BC
	POP	BC
	POP	BC
;   85		return 2.0 * int_part == d;
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JR	NZ,L__14
	LD	B,1
	JR	L__15
L__14:
	LD	B,0
L__15:
	LD	A,B
	SEXT	HL
	LD	L,B
;   86	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _IsEven ***************************
;Name                         Addr/Register   Size   Type
;_modf                               IMPORT  -----   function
;int_part                              IX-4      4   variable
;d                                     IX+6      4   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;   87	
;   88	double RoundIEEE754(double d)
;   89	{
_RoundIEEE754:
	LD	HL,-4
	CALL	__frameset
;   90		double i = floor(d);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_floor
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;   91		d -= i;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;   92		if (d < 0.5)
	LD	HL,BC
	LD	BC,0
	LD	E,(IX+9)
	LD	A,63
	CALL	__fcmp
	JP	P,L_24
;   93			return i;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	JR	L_28
L_24:
	OR	A,A
;   94		if (d > 0.5)
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	P,L_26
;   95			return i + 1.0;
	LD	HL,8388608
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fadd
	LD	E,A
	LD	HL,BC
	JR	L_28
L_26:
;   96		if (IsEven(i))
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_IsEven
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_27
;   97			return i;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	JR	L_28
L_27:
;   98		return i + 1.0;
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fadd
	LD	E,A
	LD	HL,BC
;   99	}
L_28:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _RoundIEEE754 ***************************
;Name                         Addr/Register   Size   Type
;_IsEven                             IMPORT  -----   function
;_floor                              IMPORT  -----   function
;i                                     IX-4      4   variable
;d                                     IX+6      4   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  100	
;  101	float StringToFloat(char* in)
;  102	{
_StringToFloat:
	CALL	__frameset0
;  103		return atof(in);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_atof
	POP	BC
;  104	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _StringToFloat ***************************
;Name                         Addr/Register   Size   Type
;_atof                               IMPORT  -----   function
;in                                    IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_rounders:
	DF	0.5
	DF	0.05
	DF	0.005
	DF	0.0005
	DF	0.00005
	DF	5.0E-6
	DF	5.0E-7
	DF	5.0E-8
	DF	5.0E-9
	DF	5.0E-10
	DF	5.0E-11
;  105	
;  106	#define MAX_PRECISION    (10)
;  107	static const double rounders[MAX_PRECISION + 1] =
;  108								{
	SEGMENT CODE
;  109										0.5,                // 0
;  110										0.05,                // 1
;  111										0.005,                // 2
;  112										0.0005,                // 3
;  113										0.00005,            // 4
;  114										0.000005,            // 5
;  115										0.0000005,            // 6
;  116										0.00000005,            // 7
;  117										0.000000005,        // 8
;  118										0.0000000005,        // 9
;  119										0.00000000005        // 10
;  120								};
;  121	
;  122	char* FloatToString(double f, char* buf, int precision)
;  123	{
_FloatToString:
	LD	HL,-29
	CALL	__frameset
;  124		char* ptr = buf;
	LD	BC,(IX+12)
	LD	(IX+-3),BC
;  125		char* p   = ptr;
;  126		char* p1;
;  127		char c;
;  128		long intPart;
;  129	
;  130		// check precision bounds
;  131		if (precision > MAX_PRECISION)
	LD	BC,(IX+15)
	LD	HL,10
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_33
;  132			precision = MAX_PRECISION;
	LD	BC,10
	LD	(IX+15),BC
L_33:
;  133	
;  134		// sign stuff
;  135		if (f < 0)
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_47
;  136		{
;  137			f = -f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
;  138			*ptr++ = '-';
	LD	HL,(IX+12)
	LD	(HL),45
	LD	BC,(IX+12)
	INC	BC
	LD	(IX+-3),BC
;  139		}
L_47:
;  140	
;  141		if (precision < 0)  // negative precision == automatic precision guess
	LD	HL,(IX+15)
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_49
;  142		{
;  143			if (f < 1.0) precision = 6;
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JP	P,L_45
	LD	BC,6
	LD	(IX+15),BC
;  144			else if (f < 10.0) precision = 5;
	JR	L_49
L_45:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JP	P,L_43
	LD	BC,5
	LD	(IX+15),BC
;  145			else if (f < 100.0) precision = 4;
	JR	L_49
L_43:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,13107200
	LD	A,66
	CALL	__fcmp
	JP	P,L_41
	LD	BC,4
	LD	(IX+15),BC
;  146			else if (f < 1000.0) precision = 3;
	JR	L_49
L_41:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,7995392
	LD	A,68
	CALL	__fcmp
	JP	P,L_39
	LD	BC,3
	LD	(IX+15),BC
;  147			else if (f < 10000.0) precision = 2;
	JR	L_49
L_39:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,1851392
	LD	A,70
	CALL	__fcmp
	JP	P,L_37
	LD	BC,2
	LD	(IX+15),BC
;  148			else if (f < 100000.0) precision = 1;
	JR	L_49
L_37:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,12800000
	LD	A,71
	CALL	__fcmp
	JP	P,L_35
	LD	BC,1
	LD	(IX+15),BC
;  149			else precision = 0;
	JR	L_49
L_35:
	LD	BC,0
	LD	(IX+15),BC
;  150		}
L_49:
;  151	
;  152		// round value according the precision
;  153		if (precision)
	LD	HL,(IX+15)
	CALL	__icmpzero
	JR	Z,L_50
;  154			f += rounders[precision];
	LD	HL,(IX+15)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_rounders
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+6)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	E,(IX+9)
	CALL	__fadd
	LD	(IX+6),BC
	LD	(IX+9),A
L_50:
;  155	
;  156		// integer part...
;  157		intPart = f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	(IX+-10),BC
	LD	(IX+-7),A
;  158		f -= intPart;
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  159	
;  160		if (!intPart)
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	CALL	__lcmpzero
	JR	NZ,L_61
;  161			*ptr++ = '0';
	LD	BC,(IX+-3)
	LD	(IX+-17),BC
	LD	HL,BC
	LD	(HL),48
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  162		else
	JR	L_68
L_61:
;  163		{
;  164			// save start pointer
;  165			p = ptr;
	LD	BC,(IX+-3)
	LD	(IX+-6),BC
;  166	
;  167			// convert (reverse order)
;  168			while (intPart)
	JR	L_53
L_54:
;  169			{
;  170				*p++ = '0' + intPart % 10;
	LD	BC,(IX+-6)
	LD	(IX+-20),BC
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	LD	BC,10
	XOR	A,A
	CALL	__lrems
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-20)
	LD	(HL),A
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  171				intPart /= 10;
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	XOR	A,A
	LD	BC,10
	CALL	__ldivs
	LD	(IX+-10),HL
	LD	(IX+-7),E
;  172			}
L_53:
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	CALL	__lcmpzero
	JR	NZ,L_54
;  173	
;  174			// save end pos
;  175			p1 = p;
	LD	BC,(IX+-6)
	LD	(IX+-14),BC
;  176	
;  177			// reverse result
;  178			while (p > ptr)
	JR	L_57
L_58:
;  179			{
;  180				c = *--p;
	LD	IY,(IX+-6)
	LEA	IY,IY+-1
	LD	(IX+-6),IY
	LD	HL,(IX+-6)
	LD	A,(HL)
	LD	(IX+-11),A
;  181				*p     = *ptr;
	LD	HL,(IX+-3)
	LD	A,(HL)
	LD	HL,(IX+-6)
	LD	(HL),A
;  182				*ptr++ = c;
	LD	BC,(IX+-3)
	LD	(IX+-23),BC
	LD	HL,BC
	LD	A,(IX+-11)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  183			}
L_57:
	LD	BC,(IX+-6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_58
;  184	
;  185			// restore end pos
;  186			ptr = p1;
	LD	BC,(IX+-14)
	LD	(IX+-3),BC
;  187		}
L_68:
;  188	
;  189		// decimal part
;  190		if (precision)
	LD	HL,(IX+15)
	CALL	__icmpzero
	JR	Z,L_69
;  191		{
;  192			// place decimal point
;  193			*ptr++ = '.';
	LD	BC,(IX+-3)
	LD	(IX+-26),BC
	LD	HL,BC
	LD	(HL),46
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  194	
;  195			// convert
;  196			while (precision--)
	JR	L_65
L_66:
;  197			{
;  198				f *= 10.0;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	(IX+6),BC
	LD	(IX+9),A
;  199				c = f;
;  200				*ptr++ = '0' + c;
	LD	DE,(IX+-3)
	LD	(IX+-29),DE
	LD	A,(IX+9)
	CALL	__ftol
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-29)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  201				f -= c;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	A,C
	SEXT	HL
	LD	L,C
	LD	A,H
	LD	BC,HL
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  202			}
L_65:
	LD	BC,(IX+15)
	DEC	BC
	LD	HL,(IX+15)
	CALL	__icmpzero
	LD	(IX+15),BC
	JR	NZ,L_66
;  203		}
L_69:
;  204	
;  205		// terminating zero
;  206		*ptr = 0;
	LD	HL,(IX+-3)
	LD	(HL),0
;  207	
;  208		return buf;
	LD	HL,(IX+12)
;  209	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _FloatToString ***************************
;Name                         Addr/Register   Size   Type
;_rounders                           STATIC     44   variable
;p1                                   IX-14      3   variable
;c                                    IX-11      1   variable
;intPart                              IX-10      4   variable
;p                                     IX-6      3   variable
;ptr                                   IX-3      3   variable
;precision                            IX+15      3   parameter
;buf                                  IX+12      3   parameter
;f                                     IX+6      4   parameter


; Stack Frame Size: 47 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT DATA
_PRECISION:
	DF	1.0E-14
_MAX_NUMBER_STRING_SIZE:
	DW	32
	DB	0
;  210	
;  211	static double PRECISION              = 0.00000000000001;
;  212	static int    MAX_NUMBER_STRING_SIZE = 32;
	SEGMENT CODE
;  213	
;  214	/**
;  215	 * Double to ASCII
;  216	 * Same function as FloatToString, but may have a slightly different mantissa and precision
;  217	 */
;  218	char* FloatToString2(double n, char* s)
;  219	{
_FloatToString2:
	LD	HL,-49
	CALL	__frameset
;  220		int useExp;
;  221		// handle special cases
;  222		if (isnan(n))
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_isnan
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_126
;  223		{
;  224			strcpy(s, "nan");
	LD	BC,L__39
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  225		} else if (isinf(n))
	JR	L_127
L_126:
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_isinf
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_124
;  226		{
;  227			strcpy(s, "inf");
	LD	BC,L__41
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  228		} else if (n == 0.0)
	JR	L_127
L_124:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JR	NZ,L_122
;  229		{
;  230			strcpy(s, "0");
	LD	BC,L__43
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  231		} else
	JR	L_127
L_122:
;  232		{
;  233			int digit, m, m1;
;  234			char* c = s;
	LD	BC,(IX+12)
	LD	(IX+-3),BC
;  235			int neg = (n < 0);
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L__45
	LD	B,1
	JR	L__46
L__45:
	LD	B,0
L__46:
	LD	A,B
	SEXT	HL
	LD	L,B
	LD	(IX+-18),HL
;  236			if (neg)
	CALL	__icmpzero
	JR	Z,L_72
;  237				n  = -n;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
L_72:
;  238			// calculate magnitude
;  239			m      = log10(n);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_log10
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__ftol
;  240			useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
	LD	HL,BC
	OR	A,A
	LD	DE,14
	SBC	HL,DE
	CALL	__setflag
	LD	(IX+-6),BC
	JP	P,L_76
	LD	HL,(IX+-18)
	CALL	__icmpzero
	JR	Z,L_75
	LD	BC,9
	LD	HL,(IX+-6)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_76
L_75:
	LD	BC,(IX+-6)
	LD	HL,16777207
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_77
L_76:
	LD	BC,1
	LD	(IX+-25),BC
	JR	L_78
L_77:
	LD	BC,0
	LD	(IX+-25),BC
L_78:
	LD	BC,(IX+-25)
	LD	(IX+-31),BC
;  241			if (neg)
	LD	HL,(IX+-18)
	CALL	__icmpzero
	JR	Z,L_85
;  242				*(c++) = '-';
	LD	HL,(IX+12)
	LD	(HL),45
	LD	BC,(IX+12)
	INC	BC
	LD	(IX+-3),BC
L_85:
;  243			// set up for scientific notation
;  244			if (useExp)
	LD	HL,(IX+-31)
	CALL	__icmpzero
	JR	Z,L_87
;  245			{
;  246				if (m < 0)
	LD	HL,(IX+-6)
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_83
;  247					m -= 1.0;
	LD	BC,(IX+-6)
	CALL	__itol
	CALL	__ltof
	LD	HL,8388608
	LD	E,63
	CALL	__fsub
	CALL	__ftol
	LD	(IX+-6),BC
L_83:
;  248				n  = n / pow(10.0, m);
	LD	BC,(IX+-6)
	CALL	__itol
	CALL	__ltof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	C,65
	PUSH	BC
	LD	BC,2097152
	PUSH	BC
	CALL	_pow
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	(IX+6),BC
	LD	(IX+9),A
;  249				m1 = m;
	LD	BC,(IX+-6)
	LD	(IX+-12),BC
;  250				m  = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  251			}
L_87:
;  252			if (m < 1.0)
	LD	BC,(IX+-6)
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,8388608
	LD	A,63
	CALL	__fcmp
	JP	P,L_98
;  253			{
;  254				m = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  255			}
;  256			// convert the number
;  257			while (n > PRECISION || m >= 0)
	JR	L_98
L_99:
;  258			{
;  259				double weight = pow(10.0, m);
	LD	BC,(IX+-6)
	CALL	__itol
	CALL	__ltof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	C,65
	PUSH	BC
	LD	BC,2097152
	PUSH	BC
	CALL	_pow
	LD	BC,HL
	OR	A,A
;  260				if (weight > 0 && !isinf(weight))
	SBC	HL,HL
	POP	IY
	POP	IY
	POP	IY
	POP	IY
	LD	(IX+-22),BC
	LD	(IX+-19),E
	LD	E,0
	LD	A,(IX+-19)
	CALL	__fcmp
	JP	P,L_95
	LD	C,(IX+-19)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-22)
	PUSH	BC
	CALL	_isinf
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_95
;  261				{
;  262					digit = floor(n / weight);
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_floor
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__ftol
	LD	(IX+-28),BC
;  263					n -= (digit * weight);
	CALL	__itol
	CALL	__ltof
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  264					*(c++) = '0' + digit;
	LD	BC,(IX+-3)
	LD	(IX+-34),BC
	LD	A,(IX+-28)
	ADD	A,48
	LD	HL,BC
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  265				}
L_95:
;  266				if (m == 0 && n > 0)
	LD	HL,(IX+-6)
	CALL	__icmpzero
	JR	NZ,L_97
	OR	A,A
	SBC	HL,HL
	LD	E,0
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	P,L_97
;  267					*(c++)    = '.';
	LD	BC,(IX+-3)
	LD	(IX+-37),BC
	LD	HL,BC
	LD	(HL),46
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_97:
;  268				m--;
	LD	BC,(IX+-6)
	DEC	BC
	LD	(IX+-6),BC
;  269			}
L_98:
	LD	A,(_PRECISION+3)
	LD	E,A
	LD	A,(IX+9)
	LD	HL,(_PRECISION)
	LD	BC,(IX+6)
	CALL	__fcmp
	JP	M,L_99
	LD	HL,(IX+-6)
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_99
;  270			if (useExp)
	LD	HL,(IX+-31)
	CALL	__icmpzero
	JR	Z,L_120
;  271			{
;  272				// convert the exponent
;  273				int i, j;
;  274				*(c++) = 'e';
	LD	BC,(IX+-3)
	LD	(IX+-40),BC
	LD	HL,BC
	LD	(HL),101
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  275				if (m1 > 0)
	LD	BC,(IX+-12)
	OR	A,A
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_105
;  276				{
;  277					*(c++) = '+';
	LD	HL,(IX+-3)
	LD	(HL),43
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  278				} else
	JR	L_106
L_105:
;  279				{
;  280					*(c++) = '-';
	LD	HL,(IX+-3)
	LD	(HL),45
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  281					m1 = -m1;
	LD	HL,(IX+-12)
	CALL	__ineg
	LD	(IX+-12),HL
;  282				}
L_106:
;  283				m      = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  284				while (m1 > 0)
	JR	L_109
L_110:
;  285				{
;  286					*(c++) = '0' + m1 % 10;
	LD	BC,(IX+-3)
	LD	(IX+-43),BC
	LD	HL,(IX+-12)
	LD	BC,10
	CALL	__irems
	LD	A,L
	ADD	A,48
	LD	HL,(IX+-43)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  287					m1 /= 10;
	LD	HL,(IX+-12)
	LD	BC,10
	CALL	__idivs
	LD	(IX+-12),HL
;  288					m++;
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
;  289				}
L_109:
	LD	BC,(IX+-12)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_110
;  290				c -= m;
	LD	BC,(IX+-6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-3),HL
;  291				for (i = 0, j = m - 1; i < j; i++, j--)
	LD	BC,0
	LD	(IX+-9),BC
	LD	BC,(IX+-6)
	DEC	BC
	LD	(IX+-15),BC
	JR	L_116
L_114:
;  292				{
;  293					// swap without temporary
;  294					c[i] ^= c[j];
	LD	BC,(IX+-9)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	(IX+-49),HL
	LD	BC,(IX+-9)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-3)
	LD	BC,(IX+-15)
	ADD	HL,BC
	LD	A,(IY)
	XOR	A,(HL)
	LD	HL,(IX+-49)
	LD	(HL),A
;  295					c[j] ^= c[i];
	LD	BC,(IX+-15)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	(IX+-46),HL
	LD	BC,(IX+-15)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	LD	HL,(IX+-49)
	XOR	A,(HL)
	LD	HL,(IX+-46)
	LD	(HL),A
;  296					c[i] ^= c[j];
	LD	BC,(IX+-9)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	A,(HL)
	LD	HL,(IX+-46)
	XOR	A,(HL)
	LD	HL,(IX+-3)
	LD	BC,(IX+-9)
	ADD	HL,BC
	LD	(HL),A
	LD	BC,(IX+-9)
	INC	BC
	LD	(IX+-9),BC
	LD	BC,(IX+-15)
	DEC	BC
	LD	(IX+-15),BC
;  297				}
L_116:
	LD	BC,(IX+-15)
	LD	HL,(IX+-9)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_114
;  298				c += m;
	LD	BC,(IX+-6)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	(IX+-3),HL
;  299			}
L_120:
;  300			*(c) = '\0';
	LD	HL,(IX+-3)
	LD	(HL),0
;  301		}
L_127:
;  302		return s;
	LD	HL,(IX+12)
;  303	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _FloatToString2 ***************************
;Name                         Addr/Register   Size   Type
;_PRECISION                          STATIC      4   variable
;_floor                              IMPORT  -----   function
;_pow                                IMPORT  -----   function
;_log10                              IMPORT  -----   function
;_isinf                              IMPORT  -----   function
;_strcpy                             IMPORT  -----   function
;_isnan                              IMPORT  -----   function
;useExp                               IX-31      3   variable
;digit                                IX-28      3   variable
;temp79                               IX-25      3   variable
;weight                               IX-22      4   variable
;neg                                  IX-18      3   variable
;j                                    IX-15      3   variable
;m1                                   IX-12      3   variable
;i                                     IX-9      3   variable
;m                                     IX-6      3   variable
;c                                     IX-3      3   variable
;s                                    IX+12      3   parameter
;n                                     IX+6      4   parameter


; Stack Frame Size: 64 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__39:
	DB	"nan"
	DB	0
L__41:
	DB	"inf"
	DB	0
L__43:
	DB	"0"
	DB	0
	SEGMENT CODE
;  304	
;  305	void Zero(char* ptr, int c)
;  306	{
_Zero:
	LD	HL,-3
	CALL	__frameset
;  307		int i = 0;
	LD	BC,0
	LD	(IX+-3),BC
;  308		for (; i < c; i++)
	JR	L_132
L_130:
;  309		{
;  310			ptr[i] = (char) NULL;
	LD	BC,(IX+-3)
	LD	HL,(IX+6)
	ADD	HL,BC
	LD	(HL),0
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  311		}
L_132:
	LD	BC,(IX+9)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_130
;  312	
;  313	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _Zero ***************************
;Name                         Addr/Register   Size   Type
;i                                     IX-3      3   variable
;c                                     IX+9      3   parameter
;ptr                                   IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;  314	
;  315	void FloatToStringPretty(float in, int digitLen, char* out) {
_FloatToStringPretty:
	LD	HL,-6
	CALL	__frameset
;  316		int decPlace, i;
;  317		// Weird isolated case
;  318		if (in == 10) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JR	NZ,L_135
;  319			sprintf(out, "%d", 10);
	LD	BC,10
	PUSH	BC
	LD	BC,L__70
	PUSH	BC
	LD	BC,(IX+15)
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  320			return;
	JR	L_142
;  321		}
L_135:
;  322		FloatToString2(in, out);
	LD	BC,(IX+15)
	PUSH	BC
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_FloatToString2
	POP	BC
	POP	BC
	POP	BC
;  323		decPlace = IndexOf(out, '.');
	LD	BC,46
	PUSH	BC
	LD	BC,(IX+15)
	PUSH	BC
	CALL	_IndexOf
	POP	BC
	POP	BC
	LD	(IX+-6),HL
;  324		//sprintf(g_response, ". @ %d", decPlace);
;  325		//print(g_response, 0, 2);
;  326		//sprintf(g_response, "|%s|", out);
;  327		//print(g_response, 0, 3);
;  328		if (decPlace <= -1) {
	LD	BC,HL
	LD	HL,16777215
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_142
;  329			return;
;  330		}
;  331		i = (digitLen + decPlace+1);
	LD	BC,(IX+-6)
	LD	HL,(IX+12)
	ADD	HL,BC
	INC	HL
	LD	(IX+-3),HL
;  332	
;  333		for (; i > digitLen; i--) {
	JR	L_141
L_139:
;  334			out[i] = '\0';
	LD	BC,(IX+-3)
	LD	HL,(IX+15)
	ADD	HL,BC
	LD	(HL),0
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
;  335		}
L_141:
	LD	BC,(IX+-3)
	LD	HL,(IX+12)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_139
L_142:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _FloatToStringPretty ***************************
;Name                         Addr/Register   Size   Type
;_IndexOf                            IMPORT  -----   function
;_FloatToString2                     IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;decPlace                              IX-6      3   variable
;i                                     IX-3      3   variable
;out                                  IX+15      3   parameter
;digitLen                             IX+12      3   parameter
;in                                    IX+6      4   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__70:
	DB	"%d"
	DB	0
	XREF _print:ROM
	XREF _strlen:ROM
	XREF _strchr:ROM
	XREF _strcpy:ROM
	XREF _memmove:ROM
	XREF _sprintf:ROM
	XREF _atoi:ROM
	XREF _atof:ROM
	XREF _isnan:ROM
	XREF _isinf:ROM
	XREF _modf:ROM
	XREF _floor:ROM
	XREF _pow:ROM
	XREF _log10:ROM
	XREF __idivs:ROM
	XREF __ldivs:ROM
	XREF __ineg:ROM
	XREF __irems:ROM
	XREF __lrems:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __itol:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XDEF _FloatToStringPretty
	XDEF _Zero
	XDEF _FloatToString2
	XDEF _FloatToString
	XDEF _StringToFloat
	XDEF _RoundIEEE754
	XDEF _IsEven
	XDEF _StrCut
	XDEF _GetMantissa
	XDEF _IntToChar
	XDEF _IndexOf
	XDEF _Prepend
	XDEF _EchoInput
	XDEF _g_inputBuffer
	XDEF _g_response
	END
